/*! @module Public
 */

/*! @module Xapian
 */

#define _GNU_SOURCE

extern "C" {
#include "xapian_config.h"
#include "util.h"

}

#include <xapian.h>

#include <algorithm>
#include <iostream>
#include <string>

using namespace Xapian;
using namespace std;

#include <ctype.h>

#define OBJ2_MSET(o) ((struct MSet_struct *)get_storage(o, MSet_program))
#define OBJ2_DOCUMENT(o) ((struct Document_struct *)get_storage(o, Document_program))
#define OBJ2_DATABASE(o) ((struct Database_struct *)get_storage(o, Database_program))
#define OBJ2_QUERY(o) ((struct Query_struct *)get_storage(o, Query_program))


extern "C" struct program * Document_program;
extern "C" typedef struct
{
    Database *database;
} XAPIAN_DATABASE_OBJECT_DATA;

extern "C" typedef struct
{
    Stem *stem;
} XAPIAN_STEM_OBJECT_DATA;

extern "C" typedef struct
{
    Enquire *enquire;
} XAPIAN_ENQUIRE_OBJECT_DATA;

extern "C" typedef struct
{
    Query *query;
} XAPIAN_QUERY_OBJECT_DATA;

extern "C" typedef struct
{
    MSet *mset;
} XAPIAN_MSET_OBJECT_DATA;

extern "C" typedef struct
{
    Document *document;
} XAPIAN_DOCUMENT_OBJECT_DATA;


/*! @class Query 
 */

PIKECLASS Query
{

CVAR XAPIAN_QUERY_OBJECT_DATA   *object_data;


/*! @decl void create()
 *!   Creates a new Public.Xapian.Query object
 *!
 */
PIKEFUN void create()
{
  try
  {
    Query* query = new Query();

    pop_n_elems(args);

    THIS->object_data->query = query;
  }

  catch(...) 
  {
    Pike_error("an error occurred!\n");
  }
}

PIKEFUN void create(string term, int wqf, int pos)
{
  try
  {
	string str((const char *)term->str, (size_t)term->len);
    Query* query = new Query(str, (termcount)wqf, (termpos)pos);

    pop_n_elems(args);

    THIS->object_data->query = query;
  }

  catch(...) 
  {
    Pike_error("an error occurred!\n");
  }
}

PIKEFUN int get_length()
{
  Query  *query;
  query = THIS->object_data->query;
  termcount i = query->get_length();

  push_int(i);
}

PIKEFUN int empty()
{
  Query  *query;
  query = THIS->object_data->query;
  bool i = query->empty();

  push_int(i?1:0);
}


PIKEFUN string get_description()
{
  Query  *query;
  query = THIS->object_data->query;

  string str = query->get_description();

  push_text(str.c_str());
}

INIT
{
    XAPIAN_QUERY_OBJECT_DATA * dta = 
	(XAPIAN_QUERY_OBJECT_DATA*)malloc(sizeof(XAPIAN_QUERY_OBJECT_DATA));
    if (!dta)
        Pike_error("init_sample: Out of memory!\n");

    dta->query = NULL;
    THIS->object_data = dta;
}

EXIT 
{
  if(THIS->object_data)
  {
    Query  *query;
    query = THIS->object_data->query;
    if(query) delete query;
    free(THIS->object_data);
  }
}

}

/*! @endclass
 */

/*! @class Document 
 */

PIKECLASS Document
{

CVAR XAPIAN_DOCUMENT_OBJECT_DATA   *object_data;


/*! @decl void create()
 *!   Creates a new Public.Xapian.Document object
 *!
 */
PIKEFUN void create()
{
  try
  {
    Document* document = new Document();

    pop_n_elems(args);

    THIS->object_data->document = document;
  }

  catch(...) 
  {
    Pike_error("an error occurred!\n");
  }
}

PIKEFUN void set_data(string data)
{
  Document  *doc;
  doc = THIS->object_data->document;
  string str((const char *)data->str, (size_t)data->len);

  doc->set_data(str);  

  pop_n_elems(args);
}

PIKEFUN void clear_terms()
{
  Document  *doc;
  doc = THIS->object_data->document;

  doc->clear_terms();
}

PIKEFUN void clear_values()
{
  Document  *doc;
  doc = THIS->object_data->document;

  doc->clear_values();
}

PIKEFUN string get_data()
{
  Document  *doc;
  doc = THIS->object_data->document;

  string str = doc->get_data();

  push_text(str.c_str());
}

PIKEFUN string get_description()
{
  Document  *doc;
  doc = THIS->object_data->document;

  string str = doc->get_description();

  push_text(str.c_str());
}

PIKEFUN string get_value(int val)
{
  Document  *doc;
  doc = THIS->object_data->document;

  string str = doc->get_value(val);

  pop_n_elems(args);

  if(str.length())
    push_text(str.c_str());
  else 
    push_int(0);
}

PIKEFUN void remove_value(int val)
{
  Document  *doc;
  doc = THIS->object_data->document;

  doc->remove_value(val);

  pop_n_elems(args);
}

PIKEFUN void add_term(string tname, int termcount)
{
  Document  *doc;
  doc = THIS->object_data->document;

  string str(tname->str, tname->len);
  
  doc->add_term(str, (unsigned int)termcount);

  pop_n_elems(args);
}

PIKEFUN void add_posting(string tname, int termpos, int termcount)
{
  Document  *doc;
  doc = THIS->object_data->document;

  string str(tname->str, tname->len);
  
  doc->add_posting(str, (unsigned int)termpos, (unsigned int)termcount);

  pop_n_elems(args);
}

PIKEFUN void remove_term(string tname)
{
  Document  *doc;
  doc = THIS->object_data->document;

  string str(tname->str, tname->len);
  
  try
  {
    doc->remove_term(str);
  }
  catch(InvalidArgumentError &e)
  {
    pop_n_elems(args);
    Pike_error("InvalidArgumentError\n");
  }

  pop_n_elems(args);
}

PIKEFUN void add_value(int valueno, string value)
{
  Document  *doc;
  doc = THIS->object_data->document;
  string str(value->str, value->len);

  doc->add_value(valueno, str);

  pop_n_elems(args);
}

PIKEFUN int termlist_count()
{
  Document  *doc;
  doc = THIS->object_data->document;
  unsigned int i;

  i = doc->termlist_count();

  push_int((INT_TYPE)i);

  return;
}

PIKEFUN int values_count()
{
  Document  *doc;
  doc = THIS->object_data->document;
  unsigned int i;

  i = doc->values_count();

  push_int((INT_TYPE)i);

  return;
}


INIT
{
    XAPIAN_DOCUMENT_OBJECT_DATA * dta = 
	(XAPIAN_DOCUMENT_OBJECT_DATA*)malloc(sizeof(XAPIAN_DOCUMENT_OBJECT_DATA));
    if (!dta)
        Pike_error("init_sample: Out of memory!\n");

    dta->document = NULL;
    THIS->object_data = dta;
}

EXIT 
{
  if(THIS->object_data)
  {
    
    Document  *doc;
    doc = THIS->object_data->document;
    if(doc) delete doc;
// hrm... odd.
//    if(THIS->object_data)
//      free(THIS->object_data);
  }
}

}

/*! @endclass
 */

/*! @class MSet 
 */

PIKECLASS MSet
{

CVAR XAPIAN_MSET_OBJECT_DATA   *object_data;


/*! @decl void create()
 *!   Creates a new Public.Xapian.MSet object
 *!
 */
PIKEFUN void create()
{
  try
  {
    MSet * mset = new MSet();

    pop_n_elems(args);

    THIS->object_data->mset = mset;
  }

  catch(...) 
  {
    Pike_error("an error occurred!\n");
  }
}

PIKEFUN void fetch()
{
  MSet  *mset;
  mset = THIS->object_data->mset;

  mset->fetch();
}

PIKEFUN int size()
{
  MSet  *mset;
  mset = THIS->object_data->mset;
  doccount i;

  i = mset->size();

  push_int(i);
}

PIKEFUN int get_matches_estimated()
{
  MSet  *mset;
  mset = THIS->object_data->mset;
  doccount i;

  i = mset->get_matches_estimated();

  push_int(i);
}



PIKEFUN int get_matches_upper_bound()
{
  MSet  *mset;
  mset = THIS->object_data->mset;
  doccount i;

  i = mset->get_matches_upper_bound();

  push_int(i);
}

PIKEFUN int get_firstitem()
{
  MSet  *mset;
  mset = THIS->object_data->mset;
  doccount i;

  i = mset->get_firstitem();

  push_int(i);
}


PIKEFUN int get_matches_lower_bound()
{
  MSet  *mset;
  mset = THIS->object_data->mset;
  doccount i;

  i = mset->get_matches_lower_bound();

  push_int(i);
}

PIKEFUN string get_description()
{
  MSet  *mset;
  mset = THIS->object_data->mset;

  string str = mset->get_description();

  push_text(str.c_str());
}

INIT
{
    XAPIAN_MSET_OBJECT_DATA * dta = 
	(XAPIAN_MSET_OBJECT_DATA*)malloc(sizeof(XAPIAN_MSET_OBJECT_DATA));
    if (!dta)
        Pike_error("init_sample: Out of memory!\n");

    dta->mset = NULL;
    THIS->object_data = dta;
}

EXIT 
{
  if(THIS->object_data)
  {
    MSet  *mset;
    mset = THIS->object_data->mset;
    if(mset) delete mset;
    free(THIS->object_data);
  }
}

}

/*! @endclass
 */


/*! @class Database
 */

PIKECLASS Database
{
CVAR XAPIAN_DATABASE_OBJECT_DATA   *object_data;

PIKEFUN void create(string path)
{
  string str((const char *)path->str, (size_t)path->len);
  Database * db = new Database(str);
  THIS->object_data->database = db;

  pop_n_elems(args);  
}

PIKEFUN void create()
{
  Database * db = new Database();

  THIS->object_data->database = db;
}

PIKEFUN void reopen()
{
  Database * db = THIS->object_data->database;

  db->reopen();
}

PIKEFUN void keep_alive()
{
  Database * db = THIS->object_data->database;

  db->keep_alive();
}


PIKEFUN int get_doclength(int did)
{
  Database  *db;
  db = THIS->object_data->database;

  doclength i = db->get_doclength((docid)did);
  pop_n_elems(args);
  push_int((INT_TYPE)i);
}

PIKEFUN int get_doccount()
{
  Database  *db;
  db = THIS->object_data->database;

  doccount i = db->get_doccount();
  push_int(i);
}

PIKEFUN int get_avlength()
{
  Database  *db;
  db = THIS->object_data->database;

  doclength i = db->get_avlength();
  push_int((INT_TYPE)i);
}

PIKEFUN int get_lastdocid()
{
  Database  *db;
  db = THIS->object_data->database;

  docid i = db->get_lastdocid();
  push_int((INT_TYPE)i);
}


PIKEFUN int has_positions()
{
  Database  *db;
  db = THIS->object_data->database;

  bool i = db->has_positions();

  push_int(i?1:0);
}

PIKEFUN object get_document(int id)
{
  Database  *db;
  Document doc;
  struct object * obj;
  struct Document_struct * od;

  db = (Database*)THIS->object_data->database;

  try
  {
    doc = db->get_document((docid)id);
  }

  catch(DocNotFoundError &e)
  {
    pop_n_elems(args);
    Pike_error("DocumentNotFoundError\n");
  }

  pop_n_elems(args);

  obj = low_clone(Document_program);

  od = OBJ2_DOCUMENT(obj);

  od->object_data->document = new Document(doc);
    
  push_object(obj);

}

PIKEFUN string get_description()
{
  Database  *db;
  db = THIS->object_data->database;

  string str = db->get_description();

  push_text(str.c_str());
}

INIT
{
    XAPIAN_DATABASE_OBJECT_DATA * dta = 
	(XAPIAN_DATABASE_OBJECT_DATA*)malloc(sizeof(XAPIAN_DATABASE_OBJECT_DATA));
    if (!dta)
        Pike_error("init_sample: Out of memory!\n");

    dta->database = NULL;
    THIS->object_data = dta;
}

PIKEFUN void destroy()
{
    Database  *db;
    db = THIS->object_data->database;

    if(db) 
    {
      printf("deleting db\n");
      delete db;
    }
}

EXIT 
{
  if(THIS->object_data)
  {   
    Database  *db;
    db = THIS->object_data->database;
    free(THIS->object_data);
  }
}

}

/*! @class WriteableDatabase
 */

PIKECLASS WriteableDatabase
{
INHERIT Database;

/*! @decl void create(string appname)
 *!   Creates a new Public.Xapian.WriteableDatabase object
 *!
 */
PIKEFUN void create(string path, int mode)
{
  try
  {
    const string str((const char *)path->str, (size_t)path->len);

    WritableDatabase* database = new WritableDatabase(str, mode);

    pop_n_elems(args);

    THIS->object_data->database = database;
  }

  catch(DatabaseLockError &e)
  {
    Pike_error("DatabaseLockError\n");
  }
  catch(DatabaseOpeningError &e) 
  {
    Pike_error("DatabaseOpeningError\n");
  }
  catch(InvalidArgumentError &e) 
  {
    Pike_error("InvalidArgumentError\n");
  }
}

PIKEFUN void flush()
{
  WritableDatabase  *db;
  db = (WritableDatabase*)THIS->object_data->database;

  try
  {
    db->flush();
  }
  catch(Xapian::DatabaseCorruptError &e)
  {
    Pike_error("DatabaseCorruptError\n");
  }
  catch(Xapian::DatabaseLockError &e)
  {
    Pike_error("DatabaseLockError\n");
  }
  catch(Xapian::DatabaseError &e)
  {
    Pike_error("DatabaseError\n");
  }
}

PIKEFUN int add_document(object document)
{
  WritableDatabase  *db;
  Document * doc;
  docid id;

  struct Document_struct * od;

  db = (WritableDatabase*)THIS->object_data->database;
  od = OBJ2_DOCUMENT(document);

  if(!od) Pike_error("Not a Document!\n");

  doc = od->object_data->document;

  try
  {
    id = db->add_document(*doc);
  }
  catch(Xapian::DatabaseCorruptError &e)
  {
    Pike_error("DatabaseCorruptError\n");
  }
  catch(Xapian::DatabaseError &e)
  {
    Pike_error("DatabaseError\n");
  }

  pop_n_elems(args);
  push_int(id);  
}


PIKEFUN void replace_document(int did, object document)
{
  WritableDatabase  *db;
  Document * doc;
  docid id;

  struct Document_struct * od;

  db = (WritableDatabase*)THIS->object_data->database;
  od = OBJ2_DOCUMENT(document);

  if(!od) Pike_error("Not a Document!\n");

  doc = od->object_data->document;

  try
  {
    db->replace_document((unsigned int)did, *doc);
  }
  catch(Xapian::DatabaseCorruptError &e)
  {
    Pike_error("DatabaseCorruptError\n");
  }
  catch(Xapian::DatabaseError &e)
  {
    Pike_error("DatabaseError\n");
  }

  pop_n_elems(args);
}

PIKEFUN void replace_document(string term, object document)
{
  WritableDatabase  *db;
  Document * doc;
  docid id;
  string str;
  struct Document_struct * od;

  db = (WritableDatabase*)THIS->object_data->database;
  od = OBJ2_DOCUMENT(document);

  if(!od) Pike_error("Not a Document!\n");


  doc = od->object_data->document;

  try
  {
    const string str((const char *)term->str, (size_t)term->len);
    db->replace_document(str, *doc);
  }
  catch(Xapian::DatabaseCorruptError &e)
  {
    Pike_error("DatabaseCorruptError\n");
  }
  catch(Xapian::DatabaseError &e)
  {
    Pike_error("DatabaseError\n");
  }

  pop_n_elems(args);
}

PIKEFUN void delete_document(string unique_term)
{
  WritableDatabase  *db;
  db = (WritableDatabase*)THIS->object_data->database;
  const string str((const char *)unique_term->str, (size_t)unique_term->len);
  pop_n_elems(args);

  try
  {
    db->delete_document(str);
  }
  catch(Xapian::DatabaseCorruptError &e)
  {
    Pike_error("DatabaseCorruptError\n");
  }
  catch(Xapian::DatabaseError &e)
  {
    Pike_error("DatabaseError\n");
  }

}

PIKEFUN void delete_document(int did)
{
  WritableDatabase  *db;
  db = (WritableDatabase*)THIS->object_data->database;

  try
  {
    db->delete_document((docid)did);
  }
  catch(Xapian::DatabaseCorruptError &e)
  {
    pop_n_elems(args);
    Pike_error("DatabaseCorruptError\n");
  }
  catch(Xapian::DatabaseError &e)
  {
    pop_n_elems(args);
    Pike_error("DatabaseError\n");
  }

}


PIKEFUN void begin_transaction(int flushed)
{
  WritableDatabase  *db;
  db = (WritableDatabase*)THIS->object_data->database;

  try
  {
    db->begin_transaction((bool)flushed);
  }
  catch(Xapian::InvalidOperationError &e)
  {
    pop_n_elems(args);
    Pike_error("InvalidOperationError\n");
  }
  catch(Xapian::UnimplementedError &e)
  {
    pop_n_elems(args);
    Pike_error("UnimplementedError\n");
  }

}

PIKEFUN void commit_transaction()
{
  WritableDatabase  *db;
  db = (WritableDatabase*)THIS->object_data->database;

  try
  {
    db->commit_transaction();
  }
  catch(Xapian::InvalidOperationError &e)
  {
    Pike_error("InvalidOperationError\n");
  }
  catch(Xapian::DatabaseCorruptError &e)
  {
    Pike_error("DatabaseCorruptError\n");
  }
  catch(Xapian::DatabaseError &e)
  {
    Pike_error("DatabaseError\n");
  }
  catch(Xapian::UnimplementedError &e)
  {
    Pike_error("UnimplementedError\n");
  }

}

PIKEFUN void cancel_transaction()
{
  WritableDatabase  *db;
  db = (WritableDatabase*)THIS->object_data->database;

  try
  {
    db->cancel_transaction();
  }
  catch(Xapian::InvalidOperationError &e)
  {
    Pike_error("InvalidOperationError\n");
  }
  catch(Xapian::DatabaseCorruptError &e)
  {
    Pike_error("DatabaseCorruptError\n");
  }
  catch(Xapian::DatabaseError &e)
  {
    Pike_error("DatabaseError\n");
  }
  catch(Xapian::UnimplementedError &e)
  {
    Pike_error("UnimplementedError\n");
  }

}

PIKEFUN string get_description()
{
  WritableDatabase  *db;
  db = (WritableDatabase*)THIS->object_data->database;

  string str = db->get_description();

  push_text(str.c_str());
}

}

/*! @endclass
 */

/*! @class Stem
 */

PIKECLASS Stem
{
CVAR XAPIAN_STEM_OBJECT_DATA   *object_data;


/*! @decl void create(string language)
 *! @decl void create()
 *!   Creates a new Public.Xapian.Stem object
 *!
 */
PIKEFUN void create(string language)
{
  Stem* stem;
  const string str((const char *)language->str, (size_t)language->len);

  try
  {
    stem = new Stem(str);
  }

  catch(InvalidArgumentError &e)
  {
    pop_n_elems(args);
    Pike_error("InvalidArgumentError\n");
  }

  pop_n_elems(args);

  THIS->object_data->stem = stem;
}

PIKEFUN void create()
{
    Stem* stem = new Stem();

    pop_n_elems(args);

    THIS->object_data->stem = stem;
}

PIKEFUN string stem_word(string word)
{
  Stem  *stem;
  string foo;
  const string str((const char *)word->str, (size_t)word->len);
  stem = THIS->object_data->stem;

  foo = stem->stem_word(str);
  pop_n_elems(args);
  push_text(foo.c_str());
}

PIKEFUN string get_description()
{
  Stem  *stem;
  stem = THIS->object_data->stem;

  string str = stem->get_description();

  push_text(str.c_str());
}

INIT
{
    XAPIAN_STEM_OBJECT_DATA * dta = 
	(XAPIAN_STEM_OBJECT_DATA*)malloc(sizeof(XAPIAN_STEM_OBJECT_DATA));
    if (!dta)
        Pike_error("init_sample: Out of memory!\n");

    dta->stem = NULL;
    THIS->object_data = dta;
}

PIKEFUN void destroy()
{

    Stem  *stem;
    stem = THIS->object_data->stem;

    if(stem) 
    {
      delete stem;
    }

}

EXIT 
{
  if(THIS->object_data)
  {

    Stem  *stem;
    stem = THIS->object_data->stem;
    printf("shutting down!\n");
    free(THIS->object_data);
  }
}

}

/*! @class Enquire
 */

PIKECLASS Enquire
{

CVAR XAPIAN_ENQUIRE_OBJECT_DATA   *object_data;


/*! @decl void create()
 *!   Creates a new Public.Xapian.Query object
 *!
 */
PIKEFUN void create(object database)
{
  try
  {
    Database * db;
    db = OBJ2_DATABASE(database)->object_data->database;

    Enquire * enquire = new Enquire(*db);

    pop_n_elems(args);

    THIS->object_data->enquire = enquire;
  }

  catch(...) 
  {
    Pike_error("an error occurred!\n");
  }
}

PIKEFUN void set_query(object query, int termcount)
{
  Query * q;
  Enquire  *enquire;
  enquire = THIS->object_data->enquire;

  q = OBJ2_QUERY(query)->object_data->query;

  enquire->set_query(*q, (Xapian::termcount)termcount);
  pop_n_elems(args);  
}

PIKEFUN object get_query()
{
  Enquire  *enquire;
  Query q;
  Query * q2;
  struct object* r;
  enquire = THIS->object_data->enquire;

  q = enquire->get_query();  

  q2 = new Query(q);  

  r = low_clone(Query_program);

  OBJ2_QUERY(r)->object_data->query = q2;

  push_object(r);
}

PIKEFUN object get_mset(int first, int maxitems, int checkatleast)
{
  Enquire  *enquire;
  enquire = THIS->object_data->enquire;
  MSet mset;
  struct object * o;

  try
  {
    mset = enquire->get_mset((doccount)first, (doccount)maxitems, 
           (doccount)checkatleast);

  }
  catch(InvalidArgumentError &e)
  {
    pop_n_elems(args);
    Pike_error("InvalidArgumentError\n");
  }  

  pop_n_elems(args);

  o = low_clone(MSet_program);

  OBJ2_MSET(o)->object_data->mset = new MSet(mset);

  push_object(o);
}

PIKEFUN string get_description()
{
  Enquire  *enquire;
  enquire = THIS->object_data->enquire;

  string str = enquire->get_description();

  push_text(str.c_str());
}

INIT
{
    XAPIAN_ENQUIRE_OBJECT_DATA * dta = 
	(XAPIAN_ENQUIRE_OBJECT_DATA*)malloc(sizeof(XAPIAN_ENQUIRE_OBJECT_DATA));
    if (!dta)
        Pike_error("init_sample: Out of memory!\n");

    dta->enquire = NULL;
    THIS->object_data = dta;
}

EXIT 
{
  if(THIS->object_data)
  {
    Enquire  *enquire;
    enquire = THIS->object_data->enquire;
    if(enquire) delete enquire;
    free(THIS->object_data);
  }
}

}

/*! @endclass
 */




INIT
{
}
EXIT
{
}
EXTRA
{
add_integer_constant("DB_CREATE_OR_OPEN", DB_CREATE_OR_OPEN, 0);
add_integer_constant("DB_CREATE", DB_CREATE, 0);
add_integer_constant("DB_CREATE_OR_OVERWRITE", DB_CREATE_OR_OVERWRITE, 0);
add_integer_constant("DB_OPEN", DB_OPEN, 0);
}

/*! @endclass
 */


/*! @endmodule
 */

/*! @endmodule
 */



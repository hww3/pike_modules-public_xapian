/*! @module Public
 */

/*! @module Xapian
 */

#define _GNU_SOURCE

extern "C" {
#include "xapian_config.h"
#include "util.h"

}

#include <xapian.h>

#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

using namespace Xapian;
using namespace std;

#include <ctype.h>

#define OBJ2_MSET(o) ((struct MSet_struct *)get_storage(o, MSet_program))
#define OBJ2_ESET(o) ((struct ESet_struct *)get_storage(o, ESet_program))
#define OBJ2_STEM(o) ((struct Stem_struct *)get_storage(o, Stem_program))
#define OBJ2_STOPPER(o) ((struct Stopper_struct *)get_storage(o, Stopper_program))
#define OBJ2_MSETITERATOR(o) ((struct MSetIterator_struct *)get_storage(o, MSetIterator_program))
#define OBJ2_ESETITERATOR(o) ((struct ESetIterator_struct *)get_storage(o, ESetIterator_program))
#define OBJ2_DOCUMENT(o) ((struct Document_struct *)get_storage(o, Document_program))
#define OBJ2_DATABASE(o) ((struct Database_struct *)get_storage(o, Database_program))
#define OBJ2_QUERY(o) ((struct Query_struct *)get_storage(o, Query_program))


extern "C" struct program * Document_program;
extern "C" struct program * MSetIterator_program;
extern "C" struct program * MSet_program;
extern "C" struct program * Stem_program;
extern "C" typedef struct
{
    Database *database;
} XAPIAN_DATABASE_OBJECT_DATA;

extern "C" typedef struct
{
    Stem *stem;
} XAPIAN_STEM_OBJECT_DATA;

extern "C" typedef struct
{
    Weight *weight;
} XAPIAN_WEIGHT_OBJECT_DATA;

extern "C" typedef struct
{
    QueryParser *parser;
} XAPIAN_QUERYPARSER_OBJECT_DATA;

extern "C" typedef struct
{
    Stopper *stopper;
} XAPIAN_STOPPER_OBJECT_DATA;

extern "C" typedef struct
{
    Enquire *enquire;
} XAPIAN_ENQUIRE_OBJECT_DATA;

extern "C" typedef struct
{
    Query *query;
} XAPIAN_QUERY_OBJECT_DATA;

extern "C" typedef struct
{
    MSet *mset;
} XAPIAN_MSET_OBJECT_DATA;

extern "C" typedef struct
{
    RSet *rset;
} XAPIAN_RSET_OBJECT_DATA;

extern "C" typedef struct
{
    MSetIterator *mseti;
} XAPIAN_MSETITERATOR_OBJECT_DATA;

extern "C" typedef struct
{
    ValueIterator *valuei;
} XAPIAN_VALUEITERATOR_OBJECT_DATA;

extern "C" typedef struct
{
    ESet *eset;
} XAPIAN_ESET_OBJECT_DATA;

extern "C" typedef struct
{
    ESetIterator *eseti;
} XAPIAN_ESETITERATOR_OBJECT_DATA;

extern "C" typedef struct
{
    TermIterator *termi;
} XAPIAN_TERMITERATOR_OBJECT_DATA;

extern "C" typedef struct
{
    Document *document;
} XAPIAN_DOCUMENT_OBJECT_DATA;

/*! @class Weight
*/

PIKECLASS Weight
{
CVAR XAPIAN_WEIGHT_OBJECT_DATA   *object_data;

/*  Weight.int get_sumpart_needs_doclength() */
/*! @decl int get_sumpart_needs_doclength()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN int get_sumpart_needs_doclength()
{
  Weight *weight;
  weight = THIS->object_data->weight;

  bool i = weight->get_sumpart_needs_doclength();

  push_int(i?1:0);
}

/*  Weight.float get_maxpart() */
/*! @decl float get_maxpart()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN float get_maxpart()
{
  Weight *weight;
  weight = THIS->object_data->weight;

  Xapian::weight i = weight->get_maxpart();

  push_float((FLOAT_TYPE)i);
}

/*  Weight.float get_maxextra() */
/*! @decl float get_maxextra()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN float get_maxextra()
{
  Weight *weight;
  weight = THIS->object_data->weight;

  Xapian::weight i = weight->get_maxextra();

  push_float((FLOAT_TYPE)i);
}

/*  Weight.float get_sumextra(int len) */
/*! @decl float get_sumextra(int len)
 *!
 *!  
 *! @param len
 *!  
* !
 *! @returns
 *!  
 *!
 */
PIKEFUN float get_sumextra(int len)
{
  Weight *weight;
  weight = THIS->object_data->weight;

  Xapian::weight i = weight->get_sumextra((doclength)len);

  push_float((FLOAT_TYPE)i);
}

/*  Weight.float get_sumpart(int wdf, int len) */
/*! @decl float get_sumpart(int wdf, int len)
 *!
 *!  
 *! @param wdf
 *!  
* !
 *! @param len
 *!  
* !
 *! @returns
 *!  
 *!
 */
PIKEFUN float get_sumpart(int wdf, int len)
{
  Weight *weight;
  weight = THIS->object_data->weight;

  Xapian::weight i = weight->get_sumpart((termcount)wdf, (doclength)len);

  push_float((FLOAT_TYPE)i);
}


/*  Weight.string serialise() */
/*! @decl string serialise()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN string serialise()
{
  Weight *weight;
  weight = THIS->object_data->weight;

  string str = weight->serialise();

  push_text(str.c_str());
}

/*  Weight.string name() */
/*! @decl string name()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN string name()
{
  Weight *weight;
  weight = THIS->object_data->weight;

  string str = weight->name();

  push_text(str.c_str());
}

INIT
{
    XAPIAN_WEIGHT_OBJECT_DATA * dta = 
	(XAPIAN_WEIGHT_OBJECT_DATA*)malloc(sizeof(XAPIAN_WEIGHT_OBJECT_DATA));
    if (!dta)
        Pike_error("init_sample: Out of memory!\n");

    dta->weight = NULL;
    THIS->object_data = dta;
}

/*  Weight.void destroy() */
/*! @decl void destroy()
 *!
 *!  
 *!
 */
PIKEFUN void destroy()
{

    Weight *weight;
    weight = THIS->object_data->weight;

    if(weight) 
    {
     delete weight;
    }

}

EXIT 
{
  if(THIS->object_data)
  {

    Weight  *weight;
    weight = THIS->object_data->weight;
    printf("shutting down!\n");
    free(THIS->object_data);
  }
}

}

/*!  @endclass
*/

/*! @class BM25Weight
 *! @inherit Weight
*/

PIKECLASS BM25Weight
{
  INHERIT Weight;

  PIKEFUN void create(float k1, float k2, float k3, float b, float min_normlen)
  {
    BM25Weight * weight;
    
    weight = new BM25Weight((double)k1, (double)k2, (double)k3, (double)b, (double)min_normlen);

    THIS->object_data->weight = weight;
  }

  PIKEFUN object clone()
  {
    BM25Weight * weight;
    BM25Weight * weight2;
    struct object * obj;

    weight = (BM25Weight *)THIS->object_data->weight;
    weight2 = weight->clone();

    obj = fast_clone_object(BM25Weight_program);
    OBJ2_WEIGHT(obj)->object_data->weight = (Weight *)weight2;

    push_object(obj);    
  }
}

/*!  @endclass
*/

/*! @class BoolWeight
 *! @inherit Weight
*/

PIKECLASS BoolWeight
{
  INHERIT Weight;

  PIKEFUN void create()
  {
    BoolWeight * weight;
    
    weight = new BoolWeight();

    THIS->object_data->weight = weight;
  }
}

/*!  @endclass
*/

/*! @class TradWeight
 *! @inherit Weight
*/

PIKECLASS TradWeight
{
  INHERIT Weight;

  PIKEFUN void create(float k)
  {
    TradWeight * weight;
    
    weight = new TradWeight((double)k);

    THIS->object_data->weight = weight;
  }
}

/*!  @endclass
*/

/*! @class Stopper
*/

PIKECLASS Stopper
{
CVAR XAPIAN_STOPPER_OBJECT_DATA   *object_data;

/*  Stopper.int `()(string word) */
/*! @decl int `()(string word)
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN int `()(string word)
{
  Stopper  *stopper;
  bool i;
  stopper = THIS->object_data->stopper;
  string str((const char *)word->str, (size_t)word->len);

  i = (*stopper)(str);  

  push_int(i?1:0);
}

/*  Stopper.string get_description() */
/*! @decl string get_description()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN string get_description()
{
  Stopper  *stopper;
  stopper = THIS->object_data->stopper;

  string str = stopper->get_description();

  push_text(str.c_str());
}

INIT
{
    XAPIAN_STOPPER_OBJECT_DATA * dta = 
	(XAPIAN_STOPPER_OBJECT_DATA*)malloc(sizeof(XAPIAN_STOPPER_OBJECT_DATA));
    if (!dta)
        Pike_error("init_sample: Out of memory!\n");

    dta->stopper = NULL;
    THIS->object_data = dta;
}

/*  Stopper.void destroy() */
/*! @decl void destroy()
 *!
 *!  
 *!
 */
PIKEFUN void destroy()
{

    Stopper  *stopper;
    stopper = THIS->object_data->stopper;

    if(stopper) 
    {
     delete stopper;
    }

}

EXIT 
{
  if(THIS->object_data)
  {

    Stopper  *stopper;
    stopper = THIS->object_data->stopper;
    printf("shutting down!\n");
    free(THIS->object_data);
  }
}

}

/*!  @endclass
*/

/*! @class SimpleStopper
 *! @inherit Stopper
*/

PIKECLASS SimpleStopper
{
  INHERIT Stopper;

  PIKEFUN void create()
  {
    SimpleStopper * stopper = new SimpleStopper();

    THIS->object_data->stopper = (Stopper*) stopper;
    pop_n_elems(args);
  }

  PIKEFUN void create(array words)
  {
    int i;
    vector<string> v;

    for(i = 0; i < words->size; i++)
    {  
       string str((const char *)(ITEM(words)[i].u.string->str), 
                  (size_t)(ITEM(words)[i].u.string->len));
       v.push_back(str);
    }
    
    SimpleStopper * stopper = new SimpleStopper(v.begin(), v.end());

    THIS_STOPPER->object_data->stopper = (Stopper*) stopper;
    pop_n_elems(args);
  }

  PIKEFUN void add(string word)
  {
    SimpleStopper * stopper;
    string str((const char*)word->str, (size_t)word->len);
    stopper = (SimpleStopper *)THIS_STOPPER->object_data->stopper;
    stopper->add(str);
    pop_stack();
    
  }

  
}

/*!  @endclass
*/

/*! @class Stem
*/

PIKECLASS Stem
{
CVAR XAPIAN_STEM_OBJECT_DATA   *object_data;


/*  Stem.void create(string language) */
/*! @decl void create(string language)
 *!
 *!  
 *! @param language
 *!  
* !
 *!
 */
PIKEFUN void create(string language)
{
  Stem* stem;
  const string str((const char *)language->str, (size_t)language->len);

  try
  {
    stem = new Stem(str);
  }

  catch(InvalidArgumentError &e)
  {
    pop_n_elems(args);
    Pike_error("InvalidArgumentError\n");
  }

  pop_n_elems(args);

  THIS->object_data->stem = stem;
}

/*  Stem.void create() */
/*! @decl void create()
 *!
 *!  
 *!
 */
PIKEFUN void create()
{
    Stem* stem = new Stem();

    pop_n_elems(args);

    THIS->object_data->stem = stem;
}

/*  Stem.string stem_word(string word) */
/*! @decl string stem_word(string word)
 *!
 *!  
 *! @param word
 *!  
* !
 *! @returns
 *!  
 *!
 */
PIKEFUN string stem_word(string word)
{
  Stem  *stem;
  string foo;
  const string str((const char *)word->str, (size_t)word->len);
  stem = THIS->object_data->stem;

  foo = stem->stem_word(str);
  pop_n_elems(args);
  push_text(foo.c_str());
}

/*  Stem.string get_description() */
/*! @decl string get_description()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN string get_description()
{
  Stem  *stem;
  stem = THIS->object_data->stem;

  string str = stem->get_description();

  push_text(str.c_str());
}

INIT
{
    XAPIAN_STEM_OBJECT_DATA * dta = 
	(XAPIAN_STEM_OBJECT_DATA*)malloc(sizeof(XAPIAN_STEM_OBJECT_DATA));
    if (!dta)
        Pike_error("init_sample: Out of memory!\n");

    dta->stem = NULL;
    THIS->object_data = dta;
}

/*  Stem.void destroy() */
/*! @decl void destroy()
 *!
 *!  
 *!
 */
PIKEFUN void destroy()
{

    Stem  *stem;
    stem = THIS->object_data->stem;

    if(stem) 
    {
     delete stem;
    }

}

EXIT 
{
  if(THIS->object_data)
  {

    Stem  *stem;
    stem = THIS->object_data->stem;
    printf("shutting down!\n");
    free(THIS->object_data);
  }
}

}

/*!  @endclass
*/

/*! @class Query
*/

PIKECLASS Query
{

CVAR XAPIAN_QUERY_OBJECT_DATA   *object_data;


/*  Query.void create() */
/*! @decl void create()
 *!
 *!  
 *!
 */
PIKEFUN void create()
{
  try
  {
    Query* query = new Query();

    pop_n_elems(args);

    THIS->object_data->query = query;
  }

  catch(...) 
  {
    Pike_error("an error occurred!\n");
  }
}

/*  Query.void create(string term, int wqf, int pos) */
/*! @decl void create(string term, int wqf, int pos)
 *!
 *!  
 *! @param term
 *!  
* !
 *! @param wqf
 *!  
* !
 *! @param pos
 *!  
* !
 *!
 */
PIKEFUN void create(string term, int wqf, int pos)
{
  try
  {
	string str((const char *)term->str, (size_t)term->len);
    Query* query = new Query(str, (termcount)wqf, (termpos)pos);

    pop_n_elems(args);

    THIS->object_data->query = query;
  }

  catch(...) 
  {
    Pike_error("an error occurred!\n");
  }
}

/*  Query.void create(int op, string left, string right) */
/*! @decl void create(int op, string left, string right)
 *!
 *!  
 *! @param op
 *!  
* !
 *! @param left
 *!  
* !
 *! @param right
 *!  
* !
 *!
 */
PIKEFUN void create(int op, string left, string right)
{
  try
  {
	string lstr((const char *)left->str, (size_t)left->len);
	string rstr((const char *)right->str, (size_t)right->len);
    Query* query = new Query((Xapian::Query::op)op, lstr, rstr);

    pop_n_elems(args);

    THIS->object_data->query = query;
  }

  catch(...) 
  {
    Pike_error("an error occurred!\n");
  }
}


/*  Query.void create(int op, object left, object right) */
/*! @decl void create(int op, object left, object right)
 *!
 *!  
 *! @param op
 *!  
* !
 *! @param left
 *!  
* !
 *! @param right
 *!  
* !
 *!
 */
PIKEFUN void create(int op, object left, object right)
{
  Query * l;
  Query * r;

  l = OBJ2_QUERY(left)->object_data->query;
  r = OBJ2_QUERY(right)->object_data->query;

  try
  {
    Query* query = new Query((Xapian::Query::op)op, l, r);

    pop_n_elems(args);

    THIS->object_data->query = query;
  }

  catch(...) 
  {
    Pike_error("an error occurred!\n");
  }
}

/*  Query.void create(int op, object query) */
/*! @decl void create(int op, object query)
 *!
 *!  
 *! @param op
 *!  
* !
 *! @param query
 *!  
* !
 *!
 */
PIKEFUN void create(int op, object query)
{
  Query * q;

  q = OBJ2_QUERY(query)->object_data->query;

  try
  {
    Query* qe = new Query((Xapian::Query::op)op, *q);

    pop_n_elems(args);

    THIS->object_data->query = qe;
  }

  catch(...) 
  {
    Pike_error("an error occurred!\n");
  }
}

/*  Query.int get_length() */
/*! @decl int get_length()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN int get_length()
{
  Query  *query;
  query = THIS->object_data->query;
  termcount i = query->get_length();

  push_int(i);
}

/*  Query.int empty() */
/*! @decl int empty()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN int empty()
{
  Query  *query;
  query = THIS->object_data->query;
  bool i = query->empty();

  push_int(i?1:0);
}


/*  Query.string get_description() */
/*! @decl string get_description()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN string get_description()
{
  Query  *query;
  query = THIS->object_data->query;

  string str = query->get_description();

  push_text(str.c_str());
}

INIT
{
    XAPIAN_QUERY_OBJECT_DATA * dta = 
	(XAPIAN_QUERY_OBJECT_DATA*)malloc(sizeof(XAPIAN_QUERY_OBJECT_DATA));
    if (!dta)
        Pike_error("init_sample: Out of memory!\n");

    dta->query = NULL;
    THIS->object_data = dta;
}

EXIT 
{
  if(THIS->object_data)
  {
    Query  *query;
    query = THIS->object_data->query;
     if(query) delete query;
    free(THIS->object_data);
  }
}

EXTRA
{
add_integer_constant("OP_AND", Query::OP_AND, 0);
add_integer_constant("OP_OR", Query::OP_OR, 0);
add_integer_constant("OP_AND_NOT", Query::OP_AND_NOT, 0);
add_integer_constant("OP_XOR", Query::OP_XOR, 0);
add_integer_constant("OP_AND_MAYBE", Query::OP_AND_MAYBE, 0);
add_integer_constant("OP_FILTER", Query::OP_FILTER, 0);
add_integer_constant("OP_NEAR", Query::OP_NEAR, 0);
add_integer_constant("OP_PHRASE", Query::OP_PHRASE, 0);
add_integer_constant("OP_ELITE_SET", Query::OP_ELITE_SET, 0);
}

}

/*!  @endclass
*/

/*! @class Document
*/

PIKECLASS Document
{

CVAR XAPIAN_DOCUMENT_OBJECT_DATA   *object_data;


/*  Document.void create() */
/*! @decl void create()
 *!
 *!  
 *!
 */
PIKEFUN void create()
{
  try
  {
    Document* document = new Document();

    pop_n_elems(args);

    THIS->object_data->document = document;
  }

  catch(...) 
  {
    Pike_error("an error occurred!\n");
  }
}

/*  Document.void set_data(string data) */
/*! @decl void set_data(string data)
 *!
 *!  
 *! @param data
 *!  
* !
 *!
 */
PIKEFUN void set_data(string data)
{
  Document  *doc;
  doc = THIS->object_data->document;
  string str((const char *)data->str, (size_t)data->len);

  doc->set_data(str);  

  pop_n_elems(args);
}

/*  Document.void clear_terms() */
/*! @decl void clear_terms()
 *!
 *!  
 *!
 */
PIKEFUN void clear_terms()
{
  Document  *doc;
  doc = THIS->object_data->document;

  doc->clear_terms();
}

/*  Document.void clear_values() */
/*! @decl void clear_values()
 *!
 *!  
 *!
 */
PIKEFUN void clear_values()
{
  Document  *doc;
  doc = THIS->object_data->document;

  doc->clear_values();
}

/*  Document.string get_data() */
/*! @decl string get_data()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN string get_data()
{
  Document  *doc;
  doc = THIS->object_data->document;

  string str = doc->get_data();

  push_text(str.c_str());
}

/*  Document.string get_description() */
/*! @decl string get_description()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN string get_description()
{
  Document  *doc;
  doc = THIS->object_data->document;

  string str = doc->get_description();

  push_text(str.c_str());
}

/*  Document.string get_value(int val) */
/*! @decl string get_value(int val)
 *!
 *!  
 *! @param val
 *!  
* !
 *! @returns
 *!  
 *!
 */
PIKEFUN string get_value(int val)
{
  Document  *doc;
  doc = THIS->object_data->document;

  string str = doc->get_value(val);

  pop_n_elems(args);

  if(str.length())
    push_text(str.c_str());
  else 
    push_int(0);
}

/*  Document.void remove_value(int val) */
/*! @decl void remove_value(int val)
 *!
 *!  
 *! @param val
 *!  
* !
 *!
 */
PIKEFUN void remove_value(int val)
{
  Document  *doc;
  doc = THIS->object_data->document;

  doc->remove_value(val);

  pop_n_elems(args);
}

/*  Document.void add_term(string tname, int termcount) */
/*! @decl void add_term(string tname, int termcount)
 *!
 *!  
 *! @param tname
 *!  
* !
 *! @param termcount
 *!  
* !
 *!
 */
PIKEFUN void add_term(string tname, int termcount)
{
  Document  *doc;
  doc = THIS->object_data->document;

  string str(tname->str, tname->len);
  
  doc->add_term(str, (unsigned int)termcount);

  pop_n_elems(args);
}

/*  Document.void add_posting(string tname, int termpos, int termcount) */
/*! @decl void add_posting(string tname, int termpos, int termcount)
 *!
 *!  
 *! @param tname
 *!  
* !
 *! @param termpos
 *!  
* !
 *! @param termcount
 *!  
* !
 *!
 */
PIKEFUN void add_posting(string tname, int termpos, int termcount)
{
  Document  *doc;
  doc = THIS->object_data->document;

  string str(tname->str, tname->len);

  try 
  {  

    doc->add_posting(str, (unsigned int)termpos, (unsigned int)termcount);
  }

  catch(InvalidArgumentError &e)
  {
    pop_n_elems(args);
    Pike_error(e.get_msg().c_str());
  }
  
  pop_n_elems(args);
}

/*  Document.void remove_term(string tname) */
/*! @decl void remove_term(string tname)
 *!
 *!  
 *! @param tname
 *!  
* !
 *!
 */
PIKEFUN void remove_term(string tname)
{
  Document  *doc;
  doc = THIS->object_data->document;

  string str(tname->str, tname->len);
  
  try
  {
    doc->remove_term(str);
  }
  catch(InvalidArgumentError &e)
  {
    pop_n_elems(args);
    Pike_error("InvalidArgumentError\n");
  }

  pop_n_elems(args);
}

/*  Document.void add_value(int valueno, string value) */
/*! @decl void add_value(int valueno, string value)
 *!
 *!  
 *! @param valueno
 *!  
* !
 *! @param value
 *!  
* !
 *!
 */
PIKEFUN void add_value(int valueno, string value)
{
  Document  *doc;
  doc = THIS->object_data->document;
  string str(value->str, value->len);

  doc->add_value(valueno, str);

  pop_n_elems(args);
}

/*  Document.int termlist_count() */
/*! @decl int termlist_count()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN int termlist_count()
{
  Document  *doc;
  doc = THIS->object_data->document;
  unsigned int i;

  i = doc->termlist_count();

  push_int((INT_TYPE)i);

  return;
}

/*  Document.int values_count() */
/*! @decl int values_count()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN int values_count()
{
  Document  *doc;
  doc = THIS->object_data->document;
  unsigned int i;

  i = doc->values_count();

  push_int((INT_TYPE)i);

  return;
}


INIT
{
    XAPIAN_DOCUMENT_OBJECT_DATA * dta = 
	(XAPIAN_DOCUMENT_OBJECT_DATA*)malloc(sizeof(XAPIAN_DOCUMENT_OBJECT_DATA));
    if (!dta)
        Pike_error("init_sample: Out of memory!\n");

    dta->document = NULL;
    THIS->object_data = dta;
}

EXIT 
{
  if(THIS->object_data)
  {
    
    Document  *doc;
    doc = THIS->object_data->document;
    if(doc) delete doc;
// hrm... odd.
      free(THIS->object_data);
  }
}

}

/*!  @endclass
*/

/*! @class ValueIterator
*/

PIKECLASS ValueIterator
{
  CVAR XAPIAN_VALUEITERATOR_OBJECT_DATA   *object_data;

  PIKEFUN object next()
  {
    ValueIterator  *valuei;
    valuei = THIS->object_data->valuei;
    ValueIterator *valuei2;

    struct object * o;

    valuei2 = new ValueIterator((*valuei)++);

    o = fast_clone_object(ValueIterator_program);

    OBJ2_VALUEITERATOR(o)->object_data->valuei = valuei;

    push_object(o);    
  }

  PIKEFUN int `==(mixed arg)
  {
    struct object * o;
    ValueIterator  *valuei;
    ValueIterator  *valueb;
    struct ValueIterator_struct * vis;    

    if(arg->type!= T_OBJECT) RETURN(0);
    o = arg->u.object;
    valuei = (ValueIterator*)THIS->object_data->valuei;
    vis = OBJ2_VALUEITERATOR(o);
    if(!vis) RETURN(0);

    valueb = vis->object_data->valuei;
    if(valuei == valueb) RETURN(1);
    else RETURN(0);
  }

  PIKEFUN int get_valueno()
  {
    ValueIterator  *valuei;
    valueno i;
    valuei = (ValueIterator*)THIS->object_data->valuei;
    i = valuei->get_valueno();
    push_int((INT_TYPE)i);
  }

  PIKEFUN string get_value()
  {
    ValueIterator  *valuei;
    string i;
    valuei = (ValueIterator*)THIS->object_data->valuei;
    i = (*(*valuei));
    push_text(i.c_str());
  }


/*  ValueIterator.string get_description() */
/*! @decl string get_description()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN string get_description()
{
  ValueIterator  *valuei;
  valuei = THIS->object_data->valuei;

  string str = valuei->get_description();

  push_text(str.c_str());
}

INIT
{
    XAPIAN_VALUEITERATOR_OBJECT_DATA * dta = 
	(XAPIAN_VALUEITERATOR_OBJECT_DATA*)malloc(sizeof(XAPIAN_VALUEITERATOR_OBJECT_DATA));
    if (!dta)
        Pike_error("init_sample: Out of memory!\n");

    dta->valuei = NULL;
    THIS->object_data = dta;
}

EXIT 
{
  if(THIS->object_data)
  {
    ValueIterator  *valuei;
    valuei = THIS->object_data->valuei;
    if(valuei) delete valuei;
    free(THIS->object_data);
  }
}

}

/*!  @endclass
*/

/*! @class TermIterator
*/

PIKECLASS TermIterator
{
  CVAR XAPIAN_TERMITERATOR_OBJECT_DATA   *object_data;

  PIKEFUN object next()
  {
    TermIterator  * termi;
    termi = THIS->object_data->termi;
    TermIterator *termi2;

    struct object * o;

    termi2 = new TermIterator(++(*termi));

    o = fast_clone_object(TermIterator_program);

    OBJ2_TERMITERATOR(o)->object_data->termi = termi;

    push_object(o);    
  }

  PIKEFUN int `==(mixed arg)
  {
    struct object * o;
    TermIterator  *termi;
    TermIterator  *termb;
    struct TermIterator_struct * tis;    

    if(arg->type!= T_OBJECT) RETURN(0);
    o = arg->u.object;
    termi = (TermIterator*)THIS->object_data->termi;
    tis = OBJ2_TERMITERATOR(o);
    if(!tis) RETURN(0);

    termb = tis->object_data->termi;
    if(termi == termb) RETURN(1);
    else RETURN(0);
  }

  PIKEFUN int get_wdf()
  {
    TermIterator  *termi;
    termcount i;
    termi = (TermIterator*)THIS->object_data->termi;
    i = termi->get_wdf();
    push_int((INT_TYPE)i);
  }

  PIKEFUN int get_termfreq()
  {
    TermIterator  *termi;
    doccount i;
    termi = (TermIterator*)THIS->object_data->termi;
    i = termi->get_termfreq();
    push_int((INT_TYPE)i);
  }

  PIKEFUN int positionlist_count()
  {
    TermIterator  *termi;
    termcount i;
    termi = (TermIterator*)THIS->object_data->termi;
    i = termi->positionlist_count();
    push_int((INT_TYPE)i);
  }


  PIKEFUN string get_term()
  {
    TermIterator  *termi;
    string i;
    termi = (TermIterator*)THIS->object_data->termi;
    i = (*(*termi));
    push_text(i.c_str());
  }


/*  TermIterator.string get_description() */
/*! @decl string get_description()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN string get_description()
{
  TermIterator  *termi;
  termi = THIS->object_data->termi;

  string str = termi->get_description();

  push_text(str.c_str());
}

INIT
{
    XAPIAN_TERMITERATOR_OBJECT_DATA * dta = 
	(XAPIAN_TERMITERATOR_OBJECT_DATA*)malloc(sizeof(XAPIAN_TERMITERATOR_OBJECT_DATA));
    if (!dta)
        Pike_error("init_sample: Out of memory!\n");

    dta->termi = NULL;
    THIS->object_data = dta;
}

EXIT 
{
  if(THIS->object_data)
  {
    TermIterator  *termi;
    termi = THIS->object_data->termi;
    if(termi) delete termi;
    free(THIS->object_data);
  }
}

}

/*!  @endclass
*/

/*! @class MSetIterator
*/

PIKECLASS MSetIterator
{
  CVAR XAPIAN_MSETITERATOR_OBJECT_DATA   *object_data;

  PIKEFUN object get_document()
  {
    MSetIterator  *mseti;
    Document doc;
    Document *doc2;
    struct object * o;
    mseti = (MSetIterator*)THIS->object_data->mseti;
    doc = mseti->get_document();    
    doc2 = new Document(doc);

    o = fast_clone_object(Document_program);
    OBJ2_DOCUMENT(o)->object_data->document = doc2;

    push_object(o);
  }

  PIKEFUN int get_docid()
  {
    MSetIterator  *mseti;
    docid i;
    mseti = (MSetIterator*)THIS->object_data->mseti;
    i = (*(*mseti));
    push_int((INT_TYPE)i);
  }

  PIKEFUN int get_percent()
  {
    MSetIterator  *mseti;
    docid i;
    mseti = (MSetIterator*)THIS->object_data->mseti;
    i = mseti->get_percent();
    push_int((INT_TYPE)i);
  }
  
  PIKEFUN float get_weight()
  {
    MSetIterator  *mseti;
    weight i;
    mseti = (MSetIterator*)THIS->object_data->mseti;
    i = mseti->get_weight();
    push_float((FLOAT_TYPE)i);
  }
  
  PIKEFUN int get_collapse_count()
  {
    MSetIterator  *mseti;
    docid i;
    mseti = (MSetIterator*)THIS->object_data->mseti;
    i = mseti->get_collapse_count();
    push_int((INT_TYPE)i);
  }
  
  PIKEFUN object next()
  {
    MSetIterator  *mseti;
    mseti = THIS->object_data->mseti;
    MSetIterator *mseti2;

    struct object * o;

    mseti2 = new MSetIterator((*mseti)++);

    o = fast_clone_object(MSetIterator_program);

    OBJ2_MSETITERATOR(o)->object_data->mseti = mseti2;

    push_object(o);    
  }

  PIKEFUN object prev()
  {
    MSetIterator  *mseti;
    mseti = THIS->object_data->mseti;
    MSetIterator *mseti2;

    struct object * o;

    mseti2 = new MSetIterator((*mseti)--);

    o = fast_clone_object(MSetIterator_program);

    OBJ2_MSETITERATOR(o)->object_data->mseti = mseti2;

    push_object(o);    
  }


  PIKEFUN int `==(mixed arg)
  {
    struct object * o;
    struct MSetIterator_struct * msis;    
    MSetIterator  *mseti;
    MSetIterator  *msetb;

    if(arg->type!= T_OBJECT) RETURN(0);
    o = arg->u.object;
    mseti = (MSetIterator*)THIS->object_data->mseti;
    msis = OBJ2_MSETITERATOR(o);
    if(!msis) RETURN(0);

    msetb = msis->object_data->mseti;
    if(mseti == msetb) RETURN(1);
    else RETURN(0);
  }

INIT
{
    XAPIAN_MSETITERATOR_OBJECT_DATA * dta = 
	(XAPIAN_MSETITERATOR_OBJECT_DATA*)malloc(sizeof(XAPIAN_MSETITERATOR_OBJECT_DATA));
    if (!dta)
        Pike_error("init_sample: Out of memory!\n");

    dta->mseti = NULL;
    THIS->object_data = dta;
}

EXIT 
{
  if(THIS->object_data)
  {
    MSetIterator  *mseti;
    mseti = THIS->object_data->mseti;
    if(mseti) delete mseti;
    free(THIS->object_data);
  }
}

}

/*!  @endclass
*/

/*! @class ESetIterator
*/

PIKECLASS ESetIterator
{
  CVAR XAPIAN_ESETITERATOR_OBJECT_DATA   *object_data;

  PIKEFUN string get_term()
  {
    ESetIterator  *eseti;
    string i;
    eseti = (ESetIterator*)THIS->object_data->eseti;
    i = (*(*eseti));
    push_text(i.c_str());
  }

  PIKEFUN float get_weight()
  {
    ESetIterator  *eseti;
    weight i;
    eseti = (ESetIterator*)THIS->object_data->eseti;
    i = eseti->get_weight();
    push_float((FLOAT_TYPE)i);
  }  
  
  PIKEFUN object next()
  {
    ESetIterator  *eseti;
    eseti = THIS->object_data->eseti;
    ESetIterator *eseti2;

    struct object * o;

    eseti2 = new ESetIterator((*eseti)++);

    o = fast_clone_object(ESetIterator_program);

    OBJ2_ESETITERATOR(o)->object_data->eseti = eseti2;

    push_object(o);    
  }

  PIKEFUN object prev()
  {
    ESetIterator  *eseti;
    eseti = THIS->object_data->eseti;
    ESetIterator *eseti2;

    struct object * o;

    eseti2 = new ESetIterator((*eseti)--);

    o = fast_clone_object(ESetIterator_program);

    OBJ2_ESETITERATOR(o)->object_data->eseti = eseti2;

    push_object(o);    
  }

  PIKEFUN int `==(mixed arg)
  {
    struct object * o;
    ESetIterator  *eseti;
    ESetIterator  *esetb;
    struct ESetIterator_struct * esis;    

    if(arg->type!= T_OBJECT) RETURN(0);
    o = arg->u.object;
    eseti = (ESetIterator*)THIS->object_data->eseti;

    esis = OBJ2_ESETITERATOR(o);
    if(!esis) RETURN(0);

    esetb = esis->object_data->eseti;
    if(eseti == esetb) RETURN(1);
    else RETURN(0);
  }

INIT
{
    XAPIAN_ESETITERATOR_OBJECT_DATA * dta = 
	(XAPIAN_ESETITERATOR_OBJECT_DATA*)malloc(sizeof(XAPIAN_ESETITERATOR_OBJECT_DATA));
    if (!dta)
        Pike_error("init_sample: Out of memory!\n");

    dta->eseti = NULL;
    THIS->object_data = dta;
}

EXIT 
{
  if(THIS->object_data)
  {
    ESetIterator  *eseti;
    eseti = THIS->object_data->eseti;
    if(eseti) delete eseti;
    free(THIS->object_data);
  }
}

}

/*!  @endclass
*/

/*! @class MSet
*/

PIKECLASS MSet
{
CVAR XAPIAN_MSET_OBJECT_DATA *object_data;

INIT
{
    XAPIAN_MSET_OBJECT_DATA * dta = 
	(XAPIAN_MSET_OBJECT_DATA*)malloc(sizeof(XAPIAN_MSET_OBJECT_DATA));
printf("allocated mset data.\n");
    if (!dta)
        Pike_error("init_sample: Out of memory!\n");

    dta->mset = NULL;
    THIS->object_data = dta;
}

EXIT 
{
  if(THIS->object_data)
  {
    MSet  *mset;
    mset = THIS->object_data->mset;
    if(mset) delete mset;
    free(THIS->object_data);
  }
}


/*  MSet.void create() */
/*! @decl void create()
 *!
 *!  
 *!
 */
PIKEFUN void create()
{
  try
  {
    MSet * mset = new MSet();

    pop_n_elems(args);

    THIS->object_data->mset = mset;
  }

  catch(...) 
  {
    Pike_error("an error occurred!\n");
  }
}

/*  MSet.object begin() */
/*! @decl object begin()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN object begin()
{
  MSet  *mset;
  mset = THIS->object_data->mset;

  MSetIterator mseti;
  MSetIterator *mseti2;
  struct object * o;

  mseti = mset->begin();

  mseti2 = new MSetIterator(mseti);

  o = fast_clone_object(MSetIterator_program);

  OBJ2_MSETITERATOR(o)->object_data->mseti = mseti2;

  push_object(o);    
}

/*  MSet.object end() */
/*! @decl object end()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN object end()
{
  MSet  *mset;
  mset = THIS->object_data->mset;

  MSetIterator mseti;
  MSetIterator *mseti2;
  struct object * o;

  mseti = mset->end();

  mseti2 = new MSetIterator(mseti);

  o = fast_clone_object(MSetIterator_program);

  OBJ2_MSETITERATOR(o)->object_data->mseti = mseti2;

  push_object(o);    
}

/*  MSet.object back() */
/*! @decl object back()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN object back()
{
  MSet  *mset;
  mset = THIS->object_data->mset;

  MSetIterator mseti;
  MSetIterator *mseti2;
  struct object * o;

  mseti = mset->back();

  mseti2 = new MSetIterator(mseti);

  o = fast_clone_object(MSetIterator_program);

  OBJ2_MSETITERATOR(o)->object_data->mseti = mseti2;

  push_object(o);    
}

/*  MSet.void fetch() */
/*! @decl void fetch()
 *!
 *!  
 *!
 */
PIKEFUN void fetch()
{
  MSet  *mset;
  mset = THIS->object_data->mset;

  mset->fetch();
}

/*  MSet.int size() */
/*! @decl int size()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN int size()
{
  MSet  *mset;
  mset = THIS->object_data->mset;
  doccount i;

  i = mset->size();

  push_int(i);
}

/*  MSet.int get_matches_estimated() */
/*! @decl int get_matches_estimated()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN int get_matches_estimated()
{
  MSet  *mset;
  mset = THIS->object_data->mset;
  doccount i;

  i = mset->get_matches_estimated();

  push_int(i);
}

/*  MSet.int get_matches_upper_bound() */
/*! @decl int get_matches_upper_bound()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN int get_matches_upper_bound()
{
  MSet  *mset;
  mset = THIS->object_data->mset;
  doccount i;

  i = mset->get_matches_upper_bound();

  push_int(i);
}

/*  MSet.int get_firstitem() */
/*! @decl int get_firstitem()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN int get_firstitem()
{
  MSet  *mset;
  mset = THIS->object_data->mset;
  doccount i;

  i = mset->get_firstitem();

  push_int(i);
}

/*  MSet.int get_matches_lower_bound() */
/*! @decl int get_matches_lower_bound()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN int get_matches_lower_bound()
{
  MSet  *mset;
  mset = THIS->object_data->mset;
  doccount i;

  i = mset->get_matches_lower_bound();

  push_int(i);
}

/*  MSet.string get_description() */
/*! @decl string get_description()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN string get_description()
{
  MSet  *mset;
  mset = THIS->object_data->mset;

  string str = mset->get_description();

  push_text(str.c_str());
}

}

/*!  @endclass
*/

/*! @class RSet
*/

PIKECLASS RSet
{
CVAR XAPIAN_RSET_OBJECT_DATA *object_data;

INIT
{
    XAPIAN_RSET_OBJECT_DATA * dta = 
	(XAPIAN_RSET_OBJECT_DATA*)malloc(sizeof(XAPIAN_RSET_OBJECT_DATA));
printf("allocated eset data.\n");
    if (!dta)
        Pike_error("init_sample: Out of memory!\n");

    dta->rset = NULL;
    THIS->object_data = dta;
}

EXIT 
{
  if(THIS->object_data)
  {
    RSet  *rset;
    rset = THIS->object_data->rset;
    if(rset) delete rset;
    free(THIS->object_data);
  }
}

/*  RSet.void create() */
/*! @decl void create()
 *!
 *!  
 *!
 */
PIKEFUN void create()
{
  try
  {
    RSet * rset = new RSet();

    pop_n_elems(args);

    THIS->object_data->rset = rset;
  }

  catch(...) 
  {
    Pike_error("an error occurred!\n");
  }
}

/*  RSet.int size() */
/*! @decl int size()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN int size()
{
  RSet  *rset;
  rset = THIS->object_data->rset;
  doccount i;

  i = rset->size();

  push_int(i);
}

/*  RSet.int empty() */
/*! @decl int empty()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN int empty()
{
  RSet  *rset;
  rset = THIS->object_data->rset;
  bool i;

  i = rset->empty();

  push_int(i?1:0);
}

/*  RSet.void add_document(int docid) */
/*! @decl void add_document(int docid)
 *!
 *!  
 *! @param docid
 *!  
* !
 *!
 */
PIKEFUN void add_document(int docid)
{
  RSet  *rset;
  rset = THIS->object_data->rset;

  rset->add_document((Xapian::docid)docid);

  pop_n_elems(args);
}

/*  RSet.void add_document(object iterator) */
/*! @decl void add_document(object iterator)
 *!
 *!  
 *! @param iterator
 *!  
* !
 *!
 */
PIKEFUN void add_document(object iterator)
{
  RSet  *rset;
  rset = THIS->object_data->rset;

  MSetIterator * i;

  i = OBJ2_MSETITERATOR(iterator)->object_data->mseti;

  rset->add_document(*i);

  pop_n_elems(args);
}

/*  RSet.void remove_document(int docid) */
/*! @decl void remove_document(int docid)
 *!
 *!  
 *! @param docid
 *!  
* !
 *!
 */
PIKEFUN void remove_document(int docid)
{
  RSet  *rset;
  rset = THIS->object_data->rset;

  rset->remove_document((Xapian::docid)docid);

  pop_n_elems(args);
}

/*  RSet.void remove_document(object iterator) */
/*! @decl void remove_document(object iterator)
 *!
 *!  
 *! @param iterator
 *!  
* !
 *!
 */
PIKEFUN void remove_document(object iterator)
{
  RSet  *rset;
  rset = THIS->object_data->rset;

  MSetIterator * i;

  i = OBJ2_MSETITERATOR(iterator)->object_data->mseti;

  rset->remove_document(*i);

  pop_n_elems(args);
}

/*  RSet.int contains(int docid) */
/*! @decl int contains(int docid)
 *!
 *!  
 *! @param docid
 *!  
* !
 *! @returns
 *!  
 *!
 */
PIKEFUN int contains(int docid)
{
  RSet  *rset;
  rset = THIS->object_data->rset;
  bool r;

  r = rset->contains((Xapian::docid)docid);

  pop_n_elems(args);
  push_int(r?1:0);
}

/*  RSet.int contains(object iterator) */
/*! @decl int contains(object iterator)
 *!
 *!  
 *! @param iterator
 *!  
* !
 *! @returns
 *!  
 *!
 */
PIKEFUN int contains(object iterator)
{
  RSet  *rset;
  rset = THIS->object_data->rset;
  bool r;
  MSetIterator * i;

  i = OBJ2_MSETITERATOR(iterator)->object_data->mseti;

  r = rset->contains(*i);

  pop_n_elems(args);

  push_int(r?1:0);
}

/*  RSet.string get_description() */
/*! @decl string get_description()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN string get_description()
{
  RSet  *rset;
  rset = THIS->object_data->rset;

  string str = rset->get_description();

  push_text(str.c_str());
}

}

/*!  @endclass
*/

/*! @class ESet
*/

PIKECLASS ESet
{
CVAR XAPIAN_ESET_OBJECT_DATA *object_data;

INIT
{
    XAPIAN_ESET_OBJECT_DATA * dta = 
	(XAPIAN_ESET_OBJECT_DATA*)malloc(sizeof(XAPIAN_ESET_OBJECT_DATA));
printf("allocated eset data.\n");
    if (!dta)
        Pike_error("init_sample: Out of memory!\n");

    dta->eset = NULL;
    THIS->object_data = dta;
}

EXIT 
{
  if(THIS->object_data)
  {
    ESet  *eset;
    eset = THIS->object_data->eset;
    if(eset) delete eset;
    free(THIS->object_data);
  }
}


/*  ESet.void create() */
/*! @decl void create()
 *!
 *!  
 *!
 */
PIKEFUN void create()
{
  try
  {
    ESet * eset = new ESet();

    pop_n_elems(args);

    THIS->object_data->eset = eset;
  }

  catch(...) 
  {
    Pike_error("an error occurred!\n");
  }
}

/*  ESet.object begin() */
/*! @decl object begin()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN object begin()
{
  ESet  *eset;
  eset = THIS->object_data->eset;

  ESetIterator eseti;
  ESetIterator *eseti2;
  struct object * o;

  eseti = eset->begin();

  eseti2 = new ESetIterator(eseti);

  o = fast_clone_object(ESetIterator_program);

  OBJ2_ESETITERATOR(o)->object_data->eseti = eseti2;

  push_object(o);    
}

/*  ESet.object end() */
/*! @decl object end()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN object end()
{
  ESet  *eset;
  eset = THIS->object_data->eset;

  ESetIterator eseti;
  ESetIterator *eseti2;
  struct object * o;

  eseti = eset->end();

  eseti2 = new ESetIterator(eseti);

  o = fast_clone_object(ESetIterator_program);

  OBJ2_ESETITERATOR(o)->object_data->eseti = eseti2;

  push_object(o);    
}

/*  ESet.object back() */
/*! @decl object back()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN object back()
{
  ESet  *eset;
  eset = THIS->object_data->eset;

  ESetIterator eseti;
  ESetIterator *eseti2;
  struct object * o;

  eseti = eset->back();

  eseti2 = new ESetIterator(eseti);

  o = fast_clone_object(ESetIterator_program);

  OBJ2_ESETITERATOR(o)->object_data->eseti = eseti2;

  push_object(o);    
}

/*  ESet.object `[](int i) */
/*! @decl object `[](int i)
 *!
 *!  
 *! @param i
 *!  
* !
 *! @returns
 *!  
 *!
 */
PIKEFUN object `[](int i)
{
  ESet  *eset;
  eset = THIS->object_data->eset;

  ESetIterator eseti;
  ESetIterator *eseti2;
  struct object * o;

  eseti = (*eset)[(termcount)i];

  eseti2 = new ESetIterator(eseti);

  o = fast_clone_object(ESetIterator_program);

  OBJ2_ESETITERATOR(o)->object_data->eseti = eseti2;

  push_object(o);    
}

/*  ESet.int size() */
/*! @decl int size()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN int size()
{
  ESet  *eset;
  eset = THIS->object_data->eset;
  termcount i;

  i = eset->size();

  push_int(i);
}

/*  ESet.int empty() */
/*! @decl int empty()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN int empty()
{
  ESet  *eset;
  eset = THIS->object_data->eset;
  bool i;

  i = eset->empty();

  push_int(i?1:0);
}

/*  ESet.int max_size() */
/*! @decl int max_size()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN int max_size()
{
  ESet  *eset;
  eset = THIS->object_data->eset;
  termcount i;

  i = eset->max_size();

  push_int(i);
}

/*  ESet.int get_ebound() */
/*! @decl int get_ebound()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN int get_ebound()
{
  ESet  *eset;
  eset = THIS->object_data->eset;
  termcount i;

  i = eset->get_ebound();

  push_int(i);
}

/*  ESet.string get_description() */
/*! @decl string get_description()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN string get_description()
{
  ESet  *eset;
  eset = THIS->object_data->eset;

  string str = eset->get_description();

  push_text(str.c_str());
}

}

/*!  @endclass
*/

/*! @class QueryParser
*/

PIKECLASS QueryParser
{
CVAR XAPIAN_QUERYPARSER_OBJECT_DATA   *object_data;

/*  QueryParser.void create() */
/*! @decl void create()
 *!
 *!  
 *!
 */
PIKEFUN void create()
{
  QueryParser * parser = new QueryParser();

  THIS->object_data->parser = parser;
}

/*  QueryParser.void set_stemmer(object stemmer) */
/*! @decl void set_stemmer(object stemmer)
 *!
 *!  
 *! @param stemmer
 *!  
* !
 *!
 */
PIKEFUN void set_stemmer(object stemmer)
{
  QueryParser * parser;
  Stem * s;

  parser = THIS->object_data->parser;
  s = OBJ2_STEM(stemmer)->object_data->stem; 
  parser->set_stemmer((const Stem)*s);

  pop_n_elems(args);
}

/*  QueryParser.void set_stopper(object stopper) */
/*! @decl void set_stopper(object stopper)
 *!
 *!  
 *! @param stopper
 *!  
* !
 *!
 */
PIKEFUN void set_stopper(object stopper)
{
  QueryParser * parser;
  Stopper * s;

  parser = THIS->object_data->parser;
  s = OBJ2_STOPPER(stopper)->object_data->stopper; 
  parser->set_stopper((const Stopper*)s);

  pop_n_elems(args);
}

/*  QueryParser.void set_default_op(int op) */
/*! @decl void set_default_op(int op)
 *!
 *!  
 *! @param op
 *!  
* !
 *!
 */
PIKEFUN void set_default_op(int op)
{
  QueryParser * parser;

  parser = THIS->object_data->parser;

  parser->set_default_op((Query::op)op);
  pop_n_elems(args);
}

/*  QueryParser.object parse_query(string query, int flags) */
/*! @decl object parse_query(string query, int flags)
 *!
 *!  
 *! @param query
 *!  
* !
 *! @param flags
 *!  
* !
 *! @returns
 *!  
 *!
 */
PIKEFUN object parse_query(string query, int flags)
{
  Query q;
  Query * q1;
  QueryParser *parser;
  struct object *o;
  parser = THIS->object_data->parser;

  string str((const char *)query->str, (size_t)query->len);

  q = parser->parse_query(str, flags);

  q1 = new Query(q);  

  o = fast_clone_object(Query_program);
  if(!o) Pike_error("unable to clone the query program.\n");
  if(!q1) Pike_error("unable to parse the query.\n");
  OBJ2_QUERY(o)->object_data->query = q1;
  pop_n_elems(args);
  push_object(o);
}

/*  QueryParser.void add_prefix(string field, string prefix) */
/*! @decl void add_prefix(string field, string prefix)
 *!
 *!  
 *! @param field
 *!  
* !
 *! @param prefix
 *!  
* !
 *!
 */
PIKEFUN void add_prefix(string field, string prefix)
{
  QueryParser *parser;
  parser = THIS->object_data->parser;
  
  string f((const char *)field->str, (size_t)field->len);
  string p((const char *)prefix->str, (size_t)prefix->len);

  parser->add_prefix(f, p);
  pop_n_elems(args);
}

/*  QueryParser.void add_boolean_prefix(string field, string prefix) */
/*! @decl void add_boolean_prefix(string field, string prefix)
 *!
 *!  
 *! @param field
 *!  
* !
 *! @param prefix
 *!  
* !
 *!
 */
PIKEFUN void add_boolean_prefix(string field, string prefix)
{
  QueryParser *parser;
  parser = THIS->object_data->parser;
  
  string f((const char *)field->str, (size_t)field->len);
  string p((const char *)prefix->str, (size_t)prefix->len);

  parser->add_boolean_prefix(f, p);
  pop_n_elems(args);
}

/*  QueryParser.string get_description() */
/*! @decl string get_description()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN string get_description()
{
  QueryParser *parser;
  parser = THIS->object_data->parser;

  string str = parser->get_description();

  push_text(str.c_str());
}

INIT
{
    XAPIAN_QUERYPARSER_OBJECT_DATA * dta = 
	(XAPIAN_QUERYPARSER_OBJECT_DATA*)malloc(sizeof(XAPIAN_QUERYPARSER_OBJECT_DATA));
    if (!dta)
        Pike_error("init_sample: Out of memory!\n");

    dta->parser = NULL;
    THIS->object_data = dta;
}

EXIT 
{
  if(THIS->object_data)
  {
    QueryParser  *parser;
    parser = THIS->object_data->parser;
    if(parser) delete parser;
    free(THIS->object_data);
  }
}

EXTRA
{
  QueryParser::feature_flag flag;

  flag = QueryParser::FLAG_BOOLEAN;
  add_integer_constant("FLAG_BOOLEAN", flag, 0);
  flag = QueryParser::FLAG_PHRASE;
  add_integer_constant("FLAG_PHRASE", flag, 0);
  flag = QueryParser::FLAG_LOVEHATE;
  add_integer_constant("FLAG_LOVEHATE", flag, 0);
  flag = QueryParser::FLAG_BOOLEAN_ANY_CASE;
  add_integer_constant("FLAG_BOOLEAN_ANY_CASE", flag, 0);
  flag = QueryParser::FLAG_WILDCARD;
  add_integer_constant("FLAG_WILDCARD", flag, 0);

/*
  flag = QueryParser::FLAG_PURE_NOT;
  add_integer_constant("FLAG_PURE_NOT", flag, 0);
  flag = QueryParser::FLAG_PARTIAL;
  add_integer_constant("FLAG_PARTIAL", flag, 0);
  flag = QueryParser::FLAG_SPELLING_CORRECTION;
  add_integer_constant("FLAG_SPELLING_CORRECTION", flag, 0);
  flag = QueryParser::FLAG_SYNONYM;
  add_integer_constant("FLAG_SYNONYM", flag, 0);
  flag = QueryParser::FLAG_AUTO_SYNONYMS;
  add_integer_constant("FLAG_AUTO_SYNONYMS", flag, 0);
  flag = QueryParser::FLAG_MULTIWORD_SYNONYMS;
  add_integer_constant("FLAG_MULTIWORD_SYNONYMS", flag, 0);
*/
}

}

/*!  @endclass
*/

/*! @class Database
*/

PIKECLASS Database
{
CVAR XAPIAN_DATABASE_OBJECT_DATA   *object_data;

/*  Database.void create(string path) */
/*! @decl void create(string path)
 *!
 *!  
 *! @param path
 *!  
* !
 *!
 */
PIKEFUN void create(string path)
{
  string str((const char *)path->str, (size_t)path->len);
  Database * db = new Database(str);
  THIS->object_data->database = db;

  pop_n_elems(args);  
}

/*  Database.void create() */
/*! @decl void create()
 *!
 *!  
 *!
 */
PIKEFUN void create()
{
  Database * db = new Database();

  THIS->object_data->database = db;
}

/*  Database.void reopen() */
/*! @decl void reopen()
 *!
 *!  
 *!
 */
PIKEFUN void reopen()
{
  Database * db = THIS->object_data->database;

  db->reopen();
}

/*  Database.void keep_alive() */
/*! @decl void keep_alive()
 *!
 *!  
 *!
 */
PIKEFUN void keep_alive()
{
  Database * db = THIS->object_data->database;

  db->keep_alive();
}


/*  Database.int get_doclength(int did) */
/*! @decl int get_doclength(int did)
 *!
 *!  
 *! @param did
 *!  
* !
 *! @returns
 *!  
 *!
 */
PIKEFUN int get_doclength(int did)
{
  Database  *db;
  db = THIS->object_data->database;

  doclength i = db->get_doclength((docid)did);
  pop_n_elems(args);
  push_int((INT_TYPE)i);
}

/*  Database.int get_doccount() */
/*! @decl int get_doccount()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN int get_doccount()
{
  Database  *db;
  db = THIS->object_data->database;

  doccount i = db->get_doccount();
  push_int(i);
}

/*  Database.int get_avlength() */
/*! @decl int get_avlength()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN int get_avlength()
{
  Database  *db;
  db = THIS->object_data->database;

  doclength i = db->get_avlength();
  push_int((INT_TYPE)i);
}

/*  Database.int get_lastdocid() */
/*! @decl int get_lastdocid()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN int get_lastdocid()
{
  Database  *db;
  db = THIS->object_data->database;

  docid i = db->get_lastdocid();
  push_int((INT_TYPE)i);
}


/*  Database.int has_positions() */
/*! @decl int has_positions()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN int has_positions()
{
  Database  *db;
  db = THIS->object_data->database;

  bool i = db->has_positions();

  push_int(i?1:0);
}

/*  Database.object get_document(int id) */
/*! @decl object get_document(int id)
 *!
 *!  
 *! @param id
 *!  
* !
 *! @returns
 *!  
 *!
 */
PIKEFUN object get_document(int id)
{
  Database  *db;
  Document doc;
  struct object * obj;
  struct Document_struct * od;

  db = (Database*)THIS->object_data->database;

  try
  {
    doc = db->get_document((docid)id);
  }

  catch(DocNotFoundError &e)
  {
    pop_n_elems(args);
    Pike_error("DocumentNotFoundError\n");
  }

  pop_n_elems(args);

  obj = fast_clone_object(Document_program);

  od = OBJ2_DOCUMENT(obj);

  od->object_data->document = new Document(doc);
    
  push_object(obj);

}

/*  Database.string get_description() */
/*! @decl string get_description()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN string get_description()
{
  Database  *db;
  db = THIS->object_data->database;

  string str = db->get_description();

  push_text(str.c_str());
}

INIT
{
    XAPIAN_DATABASE_OBJECT_DATA * dta = 
	(XAPIAN_DATABASE_OBJECT_DATA*)malloc(sizeof(XAPIAN_DATABASE_OBJECT_DATA));
    if (!dta)
        Pike_error("init_sample: Out of memory!\n");

    dta->database = NULL;
    THIS->object_data = dta;
}

/*  Database.void destroy() */
/*! @decl void destroy()
 *!
 *!  
 *!
 */
PIKEFUN void destroy()
{
    Database  *db;
    db = THIS->object_data->database;

    if(db) 
    {
      printf("deleting db\n");
      delete db;
    }
}

EXIT 
{
  if(THIS->object_data)
  {   
    Database  *db;
    db = THIS->object_data->database;
    free(THIS->object_data);
  }
}

}

/*!  @endclass
*/

/*! @class WriteableDatabase
 *! @inherit Database
*/

PIKECLASS WriteableDatabase
{
INHERIT Database;

/*  WriteableDatabase.void create(string path, int mode) */
/*! @decl void create(string path, int mode)
 *!
 *!  
 *! @param path
 *!  
* !
 *! @param mode
 *!  
* !
 *!
 */
PIKEFUN void create(string path, int mode)
{
  try
  {
    const string str((const char *)path->str, (size_t)path->len);

    WritableDatabase* database = new WritableDatabase(str, mode);

    pop_n_elems(args);

    THIS->object_data->database = database;
  }

  catch(DatabaseLockError &e)
  {
    Pike_error("DatabaseLockError\n");
  }
  catch(DatabaseOpeningError &e) 
  {
    Pike_error("DatabaseOpeningError\n");
  }
  catch(InvalidArgumentError &e) 
  {
    Pike_error("InvalidArgumentError\n");
  }
}

/*  WriteableDatabase.void flush() */
/*! @decl void flush()
 *!
 *!  
 *!
 */
PIKEFUN void flush()
{
  WritableDatabase  *db;
  db = (WritableDatabase*)THIS->object_data->database;

  try
  {
    db->flush();
  }
  catch(Xapian::DatabaseCorruptError &e)
  {
    Pike_error("DatabaseCorruptError\n");
  }
  catch(Xapian::DatabaseLockError &e)
  {
    Pike_error("DatabaseLockError\n");
  }
  catch(Xapian::DatabaseError &e)
  {
    Pike_error("DatabaseError\n");
  }
}

/*  WriteableDatabase.int add_document(object document) */
/*! @decl int add_document(object document)
 *!
 *!  
 *! @param document
 *!  
* !
 *! @returns
 *!  
 *!
 */
PIKEFUN int add_document(object document)
{
  WritableDatabase  *db;
  Document * doc;
  docid id;

  struct Document_struct * od;

  db = (WritableDatabase*)THIS->object_data->database;
  od = OBJ2_DOCUMENT(document);

  if(!od) Pike_error("Not a Document!\n");

  doc = od->object_data->document;

  try
  {
    id = db->add_document(*doc);
  }
  catch(Xapian::DatabaseCorruptError &e)
  {
    Pike_error("DatabaseCorruptError\n");
  }
  catch(Xapian::DatabaseError &e)
  {
    Pike_error("DatabaseError\n");
  }
  catch(Xapian::InvalidArgumentError &e)
  {
    printf("%s\n",e.get_msg().c_str());
    Pike_error("InvalidArgumentError\n");
  }
  pop_n_elems(args);
  push_int(id);  
}


/*  WriteableDatabase.void replace_document(int did, object document) */
/*! @decl void replace_document(int did, object document)
 *!
 *!  
 *! @param did
 *!  
* !
 *! @param document
 *!  
* !
 *!
 */
PIKEFUN void replace_document(int did, object document)
{
  WritableDatabase  *db;
  Document * doc;
  docid id;

  struct Document_struct * od;

  db = (WritableDatabase*)THIS->object_data->database;
  od = OBJ2_DOCUMENT(document);

  if(!od) Pike_error("Not a Document!\n");

  doc = od->object_data->document;

  try
  {
    db->replace_document((unsigned int)did, *doc);
  }
  catch(Xapian::DatabaseCorruptError &e)
  {
    Pike_error("DatabaseCorruptError\n");
  }
  catch(Xapian::DatabaseError &e)
  {
    Pike_error("DatabaseError\n");
  }

  pop_n_elems(args);
}

/*  WriteableDatabase.void replace_document(string term, object document) */
/*! @decl void replace_document(string term, object document)
 *!
 *!  
 *! @param term
 *!  
* !
 *! @param document
 *!  
* !
 *!
 */
PIKEFUN void replace_document(string term, object document)
{
  WritableDatabase  *db;
  Document * doc;
  docid id;
  string str;
  struct Document_struct * od;

  db = (WritableDatabase*)THIS->object_data->database;
  od = OBJ2_DOCUMENT(document);

  if(!od) Pike_error("Not a Document!\n");


  doc = od->object_data->document;

  try
  {
    const string str((const char *)term->str, (size_t)term->len);
    db->replace_document(str, *doc);
  }
  catch(Xapian::DatabaseCorruptError &e)
  {
    Pike_error("DatabaseCorruptError\n");
  }
  catch(Xapian::DatabaseError &e)
  {
    Pike_error("DatabaseError\n");
  }

  pop_n_elems(args);
}

/*  WriteableDatabase.void delete_document(string unique_term) */
/*! @decl void delete_document(string unique_term)
 *!
 *!  
 *! @param unique_term
 *!  
* !
 *!
 */
PIKEFUN void delete_document(string unique_term)
{
  WritableDatabase  *db;
  db = (WritableDatabase*)THIS->object_data->database;
  const string str((const char *)unique_term->str, (size_t)unique_term->len);
  pop_n_elems(args);

  try
  {
    db->delete_document(str);
  }
  catch(Xapian::DatabaseCorruptError &e)
  {
    Pike_error("DatabaseCorruptError\n");
  }
  catch(Xapian::DatabaseError &e)
  {
    Pike_error("DatabaseError\n");
  }

}

/*  WriteableDatabase.void delete_document(int did) */
/*! @decl void delete_document(int did)
 *!
 *!  
 *! @param did
 *!  
* !
 *!
 */
PIKEFUN void delete_document(int did)
{
  WritableDatabase  *db;
  db = (WritableDatabase*)THIS->object_data->database;

  try
  {
    db->delete_document((docid)did);
  }
  catch(Xapian::DatabaseCorruptError &e)
  {
    pop_n_elems(args);
    Pike_error("DatabaseCorruptError\n");
  }
  catch(Xapian::DatabaseError &e)
  {
    pop_n_elems(args);
    Pike_error("DatabaseError\n");
  }

}


/*  WriteableDatabase.void begin_transaction(int flushed) */
/*! @decl void begin_transaction(int flushed)
 *!
 *!  
 *! @param flushed
 *!  
* !
 *!
 */
PIKEFUN void begin_transaction(int flushed)
{
  WritableDatabase  *db;
  db = (WritableDatabase*)THIS->object_data->database;

  try
  {
    db->begin_transaction((bool)flushed);
  }
  catch(Xapian::InvalidOperationError &e)
  {
    pop_n_elems(args);
    Pike_error("InvalidOperationError\n");
  }
  catch(Xapian::UnimplementedError &e)
  {
    pop_n_elems(args);
    Pike_error("UnimplementedError\n");
  }

}

/*  WriteableDatabase.void commit_transaction() */
/*! @decl void commit_transaction()
 *!
 *!  
 *!
 */
PIKEFUN void commit_transaction()
{
  WritableDatabase  *db;
  db = (WritableDatabase*)THIS->object_data->database;

  try
  {
    db->commit_transaction();
  }
  catch(Xapian::InvalidOperationError &e)
  {
    Pike_error("InvalidOperationError\n");
  }
  catch(Xapian::DatabaseCorruptError &e)
  {
    Pike_error("DatabaseCorruptError\n");
  }
  catch(Xapian::DatabaseError &e)
  {
    Pike_error("DatabaseError\n");
  }
  catch(Xapian::UnimplementedError &e)
  {
    Pike_error("UnimplementedError\n");
  }

}


/*  WriteableDatabase.void cancel_transaction() */
/*! @decl void cancel_transaction()
 *!
 *!  
 *!
 */
PIKEFUN void cancel_transaction()
{
  WritableDatabase  *db;
  db = (WritableDatabase*)THIS->object_data->database;

  try
  {
    db->cancel_transaction();
  }
  catch(Xapian::InvalidOperationError &e)
  {
    Pike_error("InvalidOperationError\n");
  }
  catch(Xapian::DatabaseCorruptError &e)
  {
    Pike_error("DatabaseCorruptError\n");
  }
  catch(Xapian::DatabaseError &e)
  {
    Pike_error("DatabaseError\n");
  }
  catch(Xapian::UnimplementedError &e)
  {
    Pike_error("UnimplementedError\n");
  }

}

/*  WriteableDatabase.string get_description() */
/*! @decl string get_description()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN string get_description()
{
  WritableDatabase  *db;
  db = (WritableDatabase*)THIS->object_data->database;

  string str = db->get_description();

  push_text(str.c_str());
}

}

/*!  @endclass
*/

/*! @class Enquire
*/

PIKECLASS Enquire
{

CVAR XAPIAN_ENQUIRE_OBJECT_DATA   *object_data;


/*  Enquire.void create(object database) */
/*! @decl void create(object database)
 *!
 *!  
 *! @param database
 *!  
* !
 *!
 */
PIKEFUN void create(object database)
{
  try
  {
    Database * db;
    db = OBJ2_DATABASE(database)->object_data->database;

    Enquire * enquire = new Enquire(*db);

    pop_n_elems(args);

    THIS->object_data->enquire = enquire;
  }

  catch(...) 
  {
    Pike_error("an error occurred!\n");
  }
}

/*  Enquire.void set_weighting_scheme(object weight) */
/*! @decl void set_weighting_scheme(object weight)
 *!
 *!  
 *! @param weight
 *!  
* !
 *!
 */
PIKEFUN void set_weighting_scheme(object weight)
{
  Enquire * e = THIS->object_data->enquire;
  Weight * w = (OBJ2_WEIGHT(weight)->object_data->weight);

  e->set_weighting_scheme(*w);
  pop_n_elems(args);  
}

/*  Enquire.void set_query(object query, int termcount) */
/*! @decl void set_query(object query, int termcount)
 *!
 *!  
 *! @param query
 *!  
* !
 *! @param termcount
 *!  
* !
 *!
 */
PIKEFUN void set_query(object query, int termcount)
{
  Query * q;
  Enquire  *enquire;
  enquire = THIS->object_data->enquire;

  q = OBJ2_QUERY(query)->object_data->query;

  enquire->set_query(*q, (Xapian::termcount)termcount);
  pop_n_elems(args);  
}

/*  Enquire.void set_cutoff(int percent_cutoff, float weight_cutoff) */
/*! @decl void set_cutoff(int percent_cutoff, float weight_cutoff)
 *!
 *!  
 *! @param percent_cutoff
 *!  
* !
 *! @param weight_cutoff
 *!  
* !
 *!
 */
PIKEFUN void set_cutoff(int percent_cutoff, float weight_cutoff)
{
  Enquire  *enquire;
  enquire = THIS->object_data->enquire;

  enquire->set_cutoff((percent)percent_cutoff, (weight)weight_cutoff);
  pop_n_elems(args);  
}

/*  Enquire.void set_docid_order(int docid_order) */
/*! @decl void set_docid_order(int docid_order)
 *!
 *!  
 *! @param docid_order
 *!  
* !
 *!
 */
PIKEFUN void set_docid_order(int docid_order)
{
  Enquire  *enquire;
  enquire = THIS->object_data->enquire;

  enquire->set_docid_order((Xapian::Enquire::docid_order)docid_order);
  pop_n_elems(args);  
}

/*  Enquire.void set_collapse_key(int collapse_key) */
/*! @decl void set_collapse_key(int collapse_key)
 *!
 *!  
 *! @param collapse_key
 *!  
* !
 *!
 */
PIKEFUN void set_collapse_key(int collapse_key)
{
  Enquire  *enquire;
  enquire = THIS->object_data->enquire;

  enquire->set_collapse_key((valueno)collapse_key);
  pop_n_elems(args);  
}

/*  Enquire.void set_sort_by_relevance_then_value(int sort_key, int ascending) */
/*! @decl void set_sort_by_relevance_then_value(int sort_key, int ascending)
 *!
 *!  
 *! @param sort_key
 *!  
* !
 *! @param ascending
 *!  
* !
 *!
 */
PIKEFUN void set_sort_by_relevance_then_value(int sort_key, int ascending)
{
  Enquire  *enquire;
  enquire = THIS->object_data->enquire;

  enquire->set_sort_by_relevance_then_value((valueno)sort_key, ascending?true:false);
  pop_n_elems(args);  
}

/*  Enquire.void set_sort_by_value_then_relevance(int sort_key, int ascending) */
/*! @decl void set_sort_by_value_then_relevance(int sort_key, int ascending)
 *!
 *!  
 *! @param sort_key
 *!  
* !
 *! @param ascending
 *!  
* !
 *!
 */
PIKEFUN void set_sort_by_value_then_relevance(int sort_key, int ascending)
{
  Enquire  *enquire;
  enquire = THIS->object_data->enquire;

  enquire->set_sort_by_value_then_relevance((valueno)sort_key, ascending?true:false);
  pop_n_elems(args);  
}

/*  Enquire.void set_bias(float bias_weight, int bias_halflife) */
/*! @decl void set_bias(float bias_weight, int bias_halflife)
 *!
 *!  
 *! @param bias_weight
 *!  
* !
 *! @param bias_halflife
 *!  
* !
 *!
 */
PIKEFUN void set_bias(float bias_weight, int bias_halflife)
{
  Enquire  *enquire;
  enquire = THIS->object_data->enquire;

  enquire->set_bias((weight)bias_weight, (time_t)bias_halflife);
  pop_n_elems(args);  
}

/*  Enquire.void set_sort_value(int sort_key, int ascending) */
/*! @decl void set_sort_value(int sort_key, int ascending)
 *!
 *!  
 *! @param sort_key
 *!  
* !
 *! @param ascending
 *!  
* !
 *!
 */
PIKEFUN void set_sort_value(int sort_key, int ascending)
{
  Enquire  *enquire;
  enquire = THIS->object_data->enquire;

  enquire->set_sort_by_value((valueno)sort_key, ascending?true:false);
  pop_n_elems(args);  
}

/*  Enquire.void set_sort_by_relevence() */
/*! @decl void set_sort_by_relevence()
 *!
 *!  
 *!
 */
PIKEFUN void set_sort_by_relevence()
{
  Enquire  *enquire;
  enquire = THIS->object_data->enquire;

  enquire->set_sort_by_relevance();
}


/*  Enquire.object get_query() */
/*! @decl object get_query()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN object get_query()
{
  Enquire  *enquire;
  Query q;
  Query * q2;
  struct object* r;
  enquire = THIS->object_data->enquire;

  q = enquire->get_query();  

  q2 = new Query(q);  

  r = fast_clone_object(Query_program);

  OBJ2_QUERY(r)->object_data->query = q2;

  push_object(r);
}

/*  Enquire.object get_mset(int first, int maxitems, object rset, function mdecider) */
/*! @decl object get_mset(int first, int maxitems, object rset, function mdecider)
 *!
 *!  
 *! @param first
 *!  
* !
 *! @param maxitems
 *!  
* !
 *! @param rset
 *!  
* !
 *! @param mdecider
 *!  
* !
 *! @returns
 *!  
 *!
 */
PIKEFUN object get_mset(int first, int maxitems, object rset, function mdecider)
{
  Enquire  *enquire;
  enquire = THIS->object_data->enquire;
  MSet mset;
  MSet * mset1;
  struct object * o;
  RSet * rseto;

  rseto = OBJ2_RSET(rset)->object_data->rset;

  try
  {
    mset = enquire->get_mset((doccount)first, (doccount)maxitems, 
            rseto, 0);

  }
  catch(InvalidArgumentError &e)
  {
    pop_n_elems(args);
    Pike_error("InvalidArgumentError\n");
  }  

  pop_n_elems(args);

  o = fast_clone_object(MSet_program);
  mset1 = new MSet(mset);
  OBJ2_MSET(o)->object_data->mset = mset1;

  push_object(o);

}

/*  Enquire.object get_mset(int first, int maxitems, int checkatleast) */
/*! @decl object get_mset(int first, int maxitems, int checkatleast)
 *!
 *!  
 *! @param first
 *!  
* !
 *! @param maxitems
 *!  
* !
 *! @param checkatleast
 *!  
* !
 *! @returns
 *!  
 *!
 */
PIKEFUN object get_mset(int first, int maxitems, int checkatleast)
{
  Enquire  *enquire;
  enquire = THIS->object_data->enquire;
  MSet mset;
  MSet * mset1;
  struct object * o;

  try
  {
    mset = enquire->get_mset((doccount)first, (doccount)maxitems, 
           (doccount)checkatleast);

  }
  catch(InvalidArgumentError &e)
  {
    pop_n_elems(args);
    Pike_error("InvalidArgumentError\n");
  }  

  pop_n_elems(args);

  o = fast_clone_object(MSet_program);
  mset1 = new MSet(mset);
  OBJ2_MSET(o)->object_data->mset = mset1;

  push_object(o);
}


/*  Enquire.object get_eset(int maxitems, object rset, function edecider) */
/*! @decl object get_eset(int maxitems, object rset, function edecider)
 *!
 *!  
 *! @param maxitems
 *!  
* !
 *! @param rset
 *!  
* !
 *! @param edecider
 *!  
* !
 *! @returns
 *!  
 *!
 */
PIKEFUN object get_eset(int maxitems, object rset, function edecider)
{
  Enquire  *enquire;
  enquire = THIS->object_data->enquire;
  ESet eset;
  ESet * eset1;
  RSet * rseto;
  struct object * o;

  rseto = OBJ2_RSET(rset)->object_data->rset;
 
  try
  {
    eset = enquire->get_eset((termcount)maxitems, *rseto, 0);

  }
  catch(InvalidArgumentError &e)
  {
    pop_n_elems(args);
    Pike_error("InvalidArgumentError\n");
  }  

  pop_n_elems(args);

  o = fast_clone_object(ESet_program);
  eset1 = new ESet(eset);
  OBJ2_ESET(o)->object_data->eset = eset1;

  push_object(o);
}

/*  Enquire.object get_eset(int maxitems, object rset, int flags, float k, function edecider) */
/*! @decl object get_eset(int maxitems, object rset, int flags, float k, function edecider)
 *!
 *!  
 *! @param maxitems
 *!  
* !
 *! @param rset
 *!  
* !
 *! @param flags
 *!  
* !
 *! @param k
 *!  
* !
 *! @param edecider
 *!  
* !
 *! @returns
 *!  
 *!
 */
PIKEFUN object get_eset(int maxitems, object rset, int flags, float k, function edecider)
{
  Enquire  *enquire;
  enquire = THIS->object_data->enquire;
  ESet eset;
  ESet * eset1;
  RSet * rseto;
  struct object * o;

  rseto = OBJ2_RSET(rset)->object_data->rset;
 
  try
  {
    eset = enquire->get_eset((termcount)maxitems, *rseto, (int)flags, (double)k, 0);

  }
  catch(InvalidArgumentError &e)
  {
    pop_n_elems(args);
    Pike_error("InvalidArgumentError\n");
  }  

  pop_n_elems(args);

  o = fast_clone_object(ESet_program);
  eset1 = new ESet(eset);
  OBJ2_ESET(o)->object_data->eset = eset1;

  push_object(o);
}

/*  Enquire.string get_description() */
/*! @decl string get_description()
 *!
 *!  
 *! @returns
 *!  
 *!
 */
PIKEFUN string get_description()
{
  Enquire  *enquire;
  enquire = THIS->object_data->enquire;

  string str = enquire->get_description();

  push_text(str.c_str());
}

INIT
{
    XAPIAN_ENQUIRE_OBJECT_DATA * dta = 
	(XAPIAN_ENQUIRE_OBJECT_DATA*)malloc(sizeof(XAPIAN_ENQUIRE_OBJECT_DATA));
    if (!dta)
        Pike_error("init_sample: Out of memory!\n");

    dta->enquire = NULL;
    THIS->object_data = dta;
}

EXIT 
{
  if(THIS->object_data)
  {
    Enquire  *enquire;
    enquire = THIS->object_data->enquire;
    // if(enquire) delete enquire;
    free(THIS->object_data);
  }
}

EXTRA
{
  add_integer_constant("ASCENDING", Enquire::ASCENDING, 0);
  add_integer_constant("DESCENDING", Enquire::DESCENDING, 0);
  add_integer_constant("DONT_CARE", Enquire::DONT_CARE, 0);
}

}


INIT
{
}
EXIT
{
}
EXTRA
{
add_integer_constant("DB_CREATE_OR_OPEN", DB_CREATE_OR_OPEN, 0);
add_integer_constant("DB_CREATE", DB_CREATE, 0);
add_integer_constant("DB_CREATE_OR_OVERWRITE", DB_CREATE_OR_OVERWRITE, 0);
add_integer_constant("DB_OPEN", DB_OPEN, 0);
}

/*!  @endclass
 */

/*! @endmodule
 */

/*! @endmodule
 */


